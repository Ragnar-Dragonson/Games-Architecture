# Evaluation

The program that I have created does not include a choice implementation as this could not be completed within the time given. If I was to implement one of the choices, I would choose choice 3 as I believe this would allow players to locate items and enemies a lot easier. I would do this using an array of vectors that would be compared to the actual scene. If the vector in the array matched a vector for the maze model then a white X would be rendered within a rectangle in the bottom right of the screen, this would outline the walls of the maze allowing the player to see the shape of the maze they must traverse. The program would then check whether any of the vectors were equal to either the camera position or the drone position. If this was the case then a blue > sign would be rendered on bottom right of the screen in the position of the corresponding vector and a red > sign would be rendered in the corresponding vector position for the enemy drone. If the camera direction or the drone direction(not implemented in my design but would be with more time) changed then the symbol used to represent them would also rotate to indicate the direction these objects are facing The program will once again check its array of vectors, this time against the positions of the keys. As my keys are blue, red and yellow an O with the respective colour will be rendered on the map using the corresponding vector. The portals position will also be checked and when rendered it would be given the representation of [ ] with the colour pink allowing the portal to stand out as it is the end goal. The moving objects in room 1 and 2 would also be rendered onto the map but these will simply be given the representation of a red full stop. When the game scene closes these positions will be reset so the map data will have to be cleared each time game scenes close function is called.

The AI algorithm that is implemented within my program is very simple and only handles the drone’s movement and collision. The drone itself follows a specified path (Figure 1) starting from the center of the maze forward till it reaches the wall of the maze then it moves along the X axis till it meets the middle of room 1, the drone will then move along the Z axis down towards the center of room 2 then back along the X axis to the center of room 3 and once again back up the Z axis till the middle of room 4 where it will head again towards the center of room 1. The drone will continuously move at a velocity of 1 meter along this designated path until it has collided with the player(camera) which will reset the location of both parties and cause the drone to restart its designated pathing. When the player and the Drone collide with each other then my program subtracts 1 from the integer that stores the players lives, plays an audio file to emulate the weapons on the drone and sets the camera and the drone positions to their original render positions; center of the maze for the drone and room 4 for the player(camera). The AI does not handle rotations for the drone which causes the drone to look like it is moving backwards when it first moves and when it is moving from room 3 to room 4, the drone also looks like it is moving sideways when moving to room 1 and to room 3. This is a poor characteristic which can be corrected by adding a rotation component to the program allowing the program to use the rotation component to change the drone’s direction each time it reaches a turning point. The drone also needs to play a sound when it has seen the player, this has not been implemented as attempts were met with failure, in theory this can be implemented by taking the drones direction and checking the players(camera) position to see if the player along the axis the drone is travelling down. If the player is then the drone can be given a new audio component that plays once and is deleted again till the next time it has spotted the player.

The production of this game encountered many problems that could cause the player to have a bad experience using the game. A lot of the problems were solved during the production but a few could not be solved within the remaining time that was left on the project. The first problem I encountered was my audio continued to play even after the object did not exist anymore. I believe this was due to the fact that the audio was not being deleted properly when the entity was being removed from the game. I attempted to fix this problem by adding a delete method to delete the source of the audio but this was poorly written and caused all audio to be deleted when only the entity specific audio was supposed to be removed. To overcome this, I called a function that deleted the audio source for that entity before the entity was removed from the game. This allowed the entity specific audio to be removed leaving any other audio active audio intact. One of the problems that I occurred that I could not overcome was the collision detection between the maze and the player(camera). I attempted to achieve this collision detection by reading the normals into an extra unused public list in the objloader. I then went through this list reading its information into vectors so that a dot product could then be used on these as well as the camera position and camera direction to retrieve a float that was compared to 0. If the float was less than 0 a collision had happened and if it was greater than 0 then a collision did not occur. Unfortunately, the implementation of this code did no retrieve the desired result and the float was always above 0. Another problem that occurred was with the pathing of the object that was meant to bounce across room 1 and back again. I had gotten the bounce velocity to work so that it would constantly bounce but when it came to bouncing back between the walls it would not follow the code I had produced as it was not reaching the criteria for the if statement. I managed to fix this part by increasing the limits of the distance, which allowed the objects to move back but when they went back they did not bounce and just travelled in a straight line so I had to add another if statement to change the velocity to add an amount to the Y axis. This allowed the object to move from 1 corner to another while bouncing.
